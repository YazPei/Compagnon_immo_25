name: üöÄ Production Deployment

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DAGSHUB_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
  DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}
  DATABASE_URL: "postgresql://<username>:<password>@dagshub.com/<username>/<repo>.db"
  AWS_REGION: eu-west-1
  CLUSTER_NAME: compagnon-immo-cluster

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4

    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: üì¶ Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}

    - name: üìã Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install dagshub mlflow dvc[s3] pytest

    - name: üîó Test DagsHub connection
      run: python scripts/test_dagshub_connection.py

    - name: üß™ Run tests
      env:
        DATABASE_URL: ${{ env.DATABASE_URL }}
        JWT_SECRET_KEY: test-secret-key
        TESTING: true
      run: |
        python app/check_imports.py
        python -m pytest app/api/tests/ -v --disable-warnings --cov=app/api

    - name: üìä Upload coverage
      uses: codecov/codecov-action@v3

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: üîê Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: üè∑Ô∏è Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=sha,prefix={{branch}}-

    - name: üèóÔ∏è Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: infrastructure/docker/Dockerfile.api
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  train-model:
    needs: [test, build-and-push]
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: üìã Install ML dependencies
      run: |
        pip install -r requirements.txt
        pip install dagshub mlflow dvc[s3]

    - name: üîß Configure DagsHub
      run: |
        export MLFLOW_TRACKING_URI="https://dagshub.com/${{ secrets.DAGSHUB_USERNAME }}/compagnon-immo.mlflow"
        export MLFLOW_TRACKING_USERNAME="${{ secrets.DAGSHUB_USERNAME }}"
        export MLFLOW_TRACKING_PASSWORD="${{ secrets.DAGSHUB_TOKEN }}"

    - name: ü§ñ Train model with MLflow tracking
      run: |
        python app/ml/main.py
      env:
        MLFLOW_TRACKING_URI: "https://dagshub.com/${{ secrets.DAGSHUB_USERNAME }}/compagnon-immo.mlflow"
        MLFLOW_TRACKING_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
        MLFLOW_TRACKING_PASSWORD: ${{ secrets.DAGSHUB_TOKEN }}

    - name: üì§ Push model to DagsHub
      run: |
        dvc remote add -d dagshub-storage "https://dagshub.com/${{ secrets.DAGSHUB_USERNAME }}/compagnon-immo.dvc"
        dvc remote modify dagshub-storage --local auth basic
        dvc remote modify dagshub-storage --local user "${{ secrets.DAGSHUB_USERNAME }}"
        dvc remote modify dagshub-storage --local password "${{ secrets.DAGSHUB_TOKEN }}"
        dvc push || echo "No new data to push"

  deploy-infrastructure:
    needs: [build-and-push, train-model]
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'staging' }}
    outputs:
      api_url: ${{ steps.terraform.outputs.api_url }}
      mlflow_url: ${{ steps.terraform.outputs.mlflow_url }}
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: üîß Terraform Init
      run: |
        cd infrastructure/terraform
        terraform init

    - name: üìã Terraform Plan
      run: |
        cd infrastructure/terraform
        terraform plan -var="image_tag=${{ needs.build-and-push.outputs.image-tag }}" \
                      -var="environment=${{ github.event.inputs.environment || 'staging' }}" \
                      -var="dagshub_username=${{ secrets.DAGSHUB_USERNAME }}" \
                      -var="dagshub_token=${{ secrets.DAGSHUB_TOKEN }}"

    - name: üöÄ Terraform Apply
      id: terraform
      run: |
        cd infrastructure/terraform
        terraform apply -auto-approve \
                       -var="image_tag=${{ needs.build-and-push.outputs.image-tag }}" \
                       -var="environment=${{ github.event.inputs.environment || 'staging' }}" \
                       -var="dagshub_username=${{ secrets.DAGSHUB_USERNAME }}" \
                       -var="dagshub_token=${{ secrets.DAGSHUB_TOKEN }}"
        
        # Capture outputs
        echo "api_url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT
        echo "mlflow_url=$(terraform output -raw mlflow_url)" >> $GITHUB_OUTPUT

  deploy-kubernetes:
    needs: [deploy-infrastructure]
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üîß Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

    - name: üöÄ Deploy API to Kubernetes
      run: |
        envsubst < infrastructure/kubernetes/api-deployment.yaml | kubectl apply -f -
        kubectl rollout status deployment/compagnon-immo-api
      env:
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}
        DAGSHUB_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
        DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}

    - name: üî¨ Deploy MLflow to Kubernetes
      run: |
        envsubst < infrastructure/kubernetes/mlflow-deployment.yaml | kubectl apply -f -
        kubectl rollout status deployment/mlflow-server
      env:
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}

    - name: üîÑ Deploy Airflow to Kubernetes
      run: |
        envsubst < infrastructure/kubernetes/airflow-deployment.yaml | kubectl apply -f -
        kubectl rollout status deployment/airflow-webserver
      env:
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}

    - name: ‚è≥ Wait for all deployments
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/compagnon-immo-api
        kubectl wait --for=condition=available --timeout=300s deployment/mlflow-server
        kubectl wait --for=condition=available --timeout=300s deployment/airflow-webserver

  health-check:
    needs: [deploy-kubernetes, deploy-infrastructure]
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üè• API Health check
        run: |
          sleep 60  # Attendre que les services d√©marrent
          api_url="${{ needs.deploy-infrastructure.outputs.api_url }}"
          curl -f "${api_url}/health" 
          curl -f "${api_url}/api/v1/health"

      - name: üî¨ MLflow Health check
        run: |
          mlflow_url="${{ needs.deploy-infrastructure.outputs.mlflow_url }}"
          # MLflow n'a pas /health ‚Üí on check la page racine pour "MLflow"
          curl -fsSL "${mlflow_url}/" | grep -qi "mlflow" || echo "MLflow UI non d√©tect√©e (warning)"

      - name: üêç Setup Python (for integration tests)
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: üì¶ Install pytest (for integration tests)
        run: |
          python -m pip install --upgrade pip
          pip install pytest

      - name: üß™ Integration tests
        env:
          API_BASE_URL: ${{ needs.deploy-infrastructure.outputs.api_url }}
          MLFLOW_URL: ${{ needs.deploy-infrastructure.outputs.mlflow_url }}
          DATABASE_URL: sqlite:///:memory:
          JWT_SECRET_KEY: test-secret-key
          TESTING: "true"
        run: |
          python -m pytest app/api/tests/test_*_integration.py -v

      - name: üìä Run performance tests
        env:
          API_BASE_URL: ${{ needs.deploy-infrastructure.outputs.api_url }}
        run: |
          python scripts/test_integration.py



  streamlit-deploy:
    needs: [health-check]
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'production' || github.ref == 'refs/heads/main'
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: üé® Deploy Streamlit app
      run: |
        echo "üöÄ Deploying Streamlit interface..."
        # Ici vous pourriez d√©ployer sur Streamlit Cloud ou autre
        
    - name: üìä Configure Streamlit with API endpoint
      run: |
        echo "üîó Configuring Streamlit to use API at ${{ needs.deploy-infrastructure.outputs.api_url }}"

  monitoring-setup:
    needs: [health-check]
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4

    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üìä Setup Prometheus monitoring
      run: |
        kubectl apply -f infrastructure/kubernetes/prometheus-deployment.yaml
        kubectl rollout status deployment/prometheus

    - name: üìà Setup Grafana dashboards
      run: |
        kubectl apply -f infrastructure/kubernetes/grafana-deployment.yaml
        kubectl rollout status deployment/grafana

    - name: üîî Configure alerts
      run: |
        kubectl apply -f infrastructure/kubernetes/alertmanager-deployment.yaml

  notify:
    needs: [health-check, monitoring-setup]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: üìß Notify success
      if: success()
      run: |
        curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
             -H 'Content-type: application/json' \
             --data '{
               "text":"üéâ Compagnon Immo deployed successfully to ${{ github.event.inputs.environment || 'staging' }}!",
               "attachments":[{
                 "color":"good",
                 "fields":[
                   {"title":"Environment","value":"${{ github.event.inputs.environment || 'staging' }}","short":true},
                   {"title":"API URL","value":"${{ needs.deploy-infrastructure.outputs.api_url }}","short":true},
                   {"title":"MLflow URL","value":"${{ needs.deploy-infrastructure.outputs.mlflow_url }}","short":true},
                   {"title":"Commit","value":"${{ github.sha }}","short":true}
                 ]
               }]
             }'

    - name: üìß Notify failure
      if: failure()
      run: |
        curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
             -H 'Content-type: application/json' \
             --data '{
               "text":"‚ùå Compagnon Immo deployment failed on ${{ github.event.inputs.environment || 'staging' }}",
               "attachments":[{
                 "color":"danger",
                 "fields":[
                   {"title":"Environment","value":"${{ github.event.inputs.environment || 'staging' }}","short":true},
                   {"title":"Commit","value":"${{ github.sha }}","short":true},
                   {"title":"Workflow","value":"${{ github.workflow }}","short":true}
                 ]
               }]
             }'

    - name: üìà Update DagsHub deployment status
      run: |
        status="${{ job.status }}"
        curl -X POST \
          -H "Authorization: token ${{ secrets.DAGSHUB_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d "{
            \"status\": \"${status}\", 
            \"version\": \"${{ github.sha }}\", 
            \"environment\": \"${{ github.event.inputs.environment || 'staging' }}\",
            \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"api_url\": \"${{ needs.deploy-infrastructure.outputs.api_url }}\",
            \"mlflow_url\": \"${{ needs.deploy-infrastructure.outputs.mlflow_url }}\"
          }"

  verify-secrets:
    runs-on: ubuntu-latest
    steps:
    - name: V√©rification des secrets
      run: |
        if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
          echo "‚ùå PRODUCTION_HOST n'est pas d√©fini."
          exit 1
        fi
        if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
          echo "‚ùå PRODUCTION_SSH_KEY n'est pas d√©fini."
          exit 1
        fi
        echo "‚úÖ Tous les secrets n√©cessaires sont d√©finis."
